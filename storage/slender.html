<!DOCTYPE html>
<html lang="en-us">
<head>
  <base href="https://cdn.jsdelivr.net/gh/genizy/web-port@main/slender/">
  <meta charset="utf-8">
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <meta name="viewport" content="width=device-width, height=device-height, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Unity WebGL Player | Slender</title>
  <link rel="shortcut icon" href="TemplateData/favicon.ico">

  <style>
    * { margin:0; padding:0; border:0; overflow:hidden; }
    body { background:#000; position:fixed; width:100%; height:100%; }
    .webgl-content, #unityContainer { position:absolute; width:100%; height:100%; }
    /* Pointer-lock hint + hide cursor while locked */
    #lockHint {
      position:fixed; left:50%; top:16px; transform:translateX(-50%);
      background:rgba(0,0,0,.6); color:#fff; padding:8px 12px; border-radius:8px;
      font:600 13px/1.2 system-ui,-apple-system,Segoe UI,Roboto,sans-serif;
      z-index:9999; display:none; user-select:none;
    }
    .locked, .locked * { cursor:none !important; }
    #loading-text { color:#fff; font-size:48px; font-family:cursive; text-align:center; margin-top:20px; }
    .footer { position:absolute; bottom:0; width:100%; text-align:center; padding:10px 0;
      background:rgba(0,0,0,0.5); z-index:100; }
    .fullscreen { cursor:pointer; display:inline-block; width:24px; height:24px;
      background:url('TemplateData/fullscreen.png') no-repeat center; }
  </style>

  <script src="TemplateData/UnityProgress.js"></script>
  <script src="Build/UnityLoader.js"></script>

  <script>
    function mergeFiles(fileParts) {
      return new Promise((resolve, reject) => {
        let buffers = [];
        (function fetchPart(i){
          if(i >= fileParts.length){
            let mergedBlob = new Blob(buffers);
            resolve(URL.createObjectURL(mergedBlob));
            return;
          }
          fetch(fileParts[i]).then(r=>r.arrayBuffer()).then(data=>{
            buffers.push(data); fetchPart(i+1);
          }).catch(reject);
        })(0);
      });
    }
    function getParts(file, start, end) {
      let parts = []; for (let i=start; i<=end; i++) parts.push(file + ".part" + i);
      return parts;
    }
    function resizeUnityContainer() {
      var container = document.getElementById("unityContainer");
      container.style.width = window.innerWidth + "px";
      container.style.height = window.innerHeight + "px";
    }

    // Start loading merged data, then boot Unity
    Promise.all([
      mergeFiles(getParts("Build/Build.data.unityweb", 1, 2))
    ]).then(([dataUrl]) => {
      var json = {
        "companyName":"Parsec Productions",
        "productName":"Slender",
        "dataUrl": dataUrl,
        "asmCodeUrl":"Build.asm.code.unityweb",
        "asmMemoryUrl":"Build.asm.memory.unityweb",
        "asmFrameworkUrl":"Build.asm.framework.unityweb",
        "TOTAL_MEMORY":268435456,
        "graphicsAPI":["WebGL 2.0","WebGL 1.0"],
        "webglContextAttributes":{"preserveDrawingBuffer":false},
        "splashScreenStyle":"Dark",
        "backgroundColor":"#000000"
      };
      let blob = new Blob([JSON.stringify(json)], { type:'application/json' });
      let blobUrl = URL.createObjectURL(blob);

      window.addEventListener('resize', resizeUnityContainer);
      UnityLoader.instantiate("unityContainer", json, {
        onProgress: UnityProgress,
        url: blobUrl,
        Module: {
          onRuntimeInitialized: function () {
            resizeUnityContainer();
            const lt = document.querySelector("#loading-text");
            if (lt) lt.remove();
          }
        }
      });
    });
  </script>
</head>
<body>
  <div class="webgl-content">
    <div id="loading-text">LOADING...</div>
    <div id="unityContainer"></div>
  </div>

  <!-- Pointer Lock: click canvas to lock -->
  <div id="lockHint">Click the game to lock the mouse. Press Esc to unlock.</div>
  <script>
    (function () {
      const hint = document.getElementById('lockHint');

      function showHint(msg, ms=2500) {
        hint.textContent = msg; hint.style.display = 'block';
        clearTimeout(showHint._t); showHint._t = setTimeout(()=> hint.style.display='none', ms);
      }
      function onLockChange(canvas) {
        const locked = (document.pointerLockElement || document.mozPointerLockElement) === canvas;
        document.body.classList.toggle('locked', locked);
        if (!locked) showHint('Mouse unlocked (Esc). Click game to lock again.');
      }
      function attach(canvas) {
        if (!canvas || canvas._plAttached) return;
        canvas._plAttached = true;

        canvas.addEventListener('click', () => {
          const req = canvas.requestPointerLock || canvas.mozRequestPointerLock;
          if (req) req.call(canvas);
          else showHint('Pointer lock not supported in this browser.', 3000);
        });

        document.addEventListener('pointerlockchange', () => onLockChange(canvas));
        document.addEventListener('mozpointerlockchange', () => onLockChange(canvas));
        document.addEventListener('pointerlockerror', () =>
          showHint('Could not lock mouse. If embedded, ensure the iframe allows pointer-lock.', 4000)
        );

        // optional hotkey to re-lock
        window.addEventListener('keydown', (e) => {
          if (e.code === 'KeyL' && document.pointerLockElement !== canvas) {
            (canvas.requestPointerLock || canvas.mozRequestPointerLock)?.call(canvas);
          }
        });

        showHint('Click the game to lock the mouse. Press Esc to unlock.');
      }

      // UnityLoader creates the canvas dynamically inside #unityContainer â†’ observe for it
      const target = document.getElementById('unityContainer');
      function findCanvas(){ return target.querySelector('canvas') || document.querySelector('#unityContainer canvas'); }

      const existing = findCanvas();
      if (existing) attach(existing);

      const obs = new MutationObserver(() => {
        const c = findCanvas();
        if (c) attach(c);
      });
      obs.observe(target, { childList:true, subtree:true });

      // fallback polling (in case of wholesale replacement)
      let tries = 0;
      const iv = setInterval(() => {
        const c = findCanvas();
        if (c || tries++ > 200) { clearInterval(iv); if (c) attach(c); }
      }, 100);
    })();
  </script>
</body>
</html>
